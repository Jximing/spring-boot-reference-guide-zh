## 27.1 The “Spring Web MVC Framework”


## 27.2 The “Spring WebFlux Framework”

Spring WebFlux 是 Spring Framework 5.0 中引入的新的响应式 Web 框架。与 Spring MVC 不同，它不需要 Servlet API，完全异步且无阻塞，并通过 [Reactor project](https://projectreactor.io/) 实现 [Reactive Streams](http://www.reactive-streams.org/) 规范。

Spring WebFlux 有两种版本：`函数式` 和 `基于注解`。`基于注解` 非常接近 Spring MVC 模型，如以下示例所示：

```java
@RestController
@RequestMapping("/users")
public class MyRestController {

	@GetMapping("/{user}")
	public Mono<User> getUser(@PathVariable Long user) {
		// ...
	}

	@GetMapping("/{user}/customers")
	public Flux<Customer> getUserCustomers(@PathVariable Long user) {
		// ...
	}

	@DeleteMapping("/{user}")
	public Mono<User> deleteUser(@PathVariable Long user) {
		// ...
	}

}
```

“WebFlux.fn” 是 `函数式` 的变种，它将路由配置与请求的实际处理分开，如以下示例所示：

```java
@Configuration
public class RoutingConfiguration {

	@Bean
	public RouterFunction<ServerResponse> monoRouterFunction(UserHandler userHandler) {
		return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
				.andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
				.andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
	}

}

@Component
public class UserHandler {

	public Mono<ServerResponse> getUser(ServerRequest request) {
		// ...
	}

	public Mono<ServerResponse> getUserCustomers(ServerRequest request) {
		// ...
	}

	public Mono<ServerResponse> deleteUser(ServerRequest request) {
		// ...
	}
}
```

WebFlux 是 Spring Framework 的一部分，详细信息可在其 [参考文档](https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn) 中找到。

> :sunny: 您可以根据需要定义尽可能多的 `RouterFunction` beans 来模块化路由器的定义。如果你需要一个优先级，beans 可以被排序。

首先，将 `spring-boot-starter-webflux` 模块添加到您的应用程序中。

> :sunny: 在应用程序中同时添加 `spring-boot-starter-web` 和 `spring-boot-starter-webflux` 模块会导致 Spring Boot 自动配置 Spring MVC ，而不是 WebFlux 。这样做的原因是因为许多 Spring 开发人员将 `spring-boot-starter-webflux` 添加到他们的 Spring MVC 应用程序中以使用反应式 `WebClient` 。您仍然可以通过将所选应用程序类型设置为 `SpringApplicationsetWebApplicationType`(`WebApplicationType.REACTIVE`) 来强制执行您的选择。


- ##### 27.2.1 Spring WebFlux Auto-configuration

	Spring Boot 为 Spring WebFlux 提供自动配置，适用于大多数应用程序。

	自动配置在 Spring 的默认功能之上添加了以下功能：

	- 为 `HttpMessageReader` 和 `HttpMessageWriter` 实例配置编解码器

	- 支持提供静态资源，包括对 WebJars 的支持

	如果要保留 Spring Boot WebFlux 功能并且想要添加其他 [WebFlux配置](https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/web.html#web-reactive)，可以添加自己的 `@Configuration` 类，类型为 `WebFluxConfigurer` ，但不包含`@EnableWebFlux` 。

	如果您想完全控制 Spring WebFlux ，可以使用 `@EnableWebFlux` 添加自己的 `@Configuration` 注释。


- #### 27.2.2 HTTP Codecs with HttpMessageReaders and HttpMessageWriters

	Spring WebFlux 使用 `HttpMessageReader` 和 `HttpMessageWriter` 接口来转换 HTTP 请求和响应。通过查看类路径中可用的库，它们配置了 `CodecConfigurer` 以具有合理的默认值。

	Spring Boot 通过使用 `CodecCustomizer` 实例进一步定制。例如，`spring.jackson.*` 配置 key 使用 Jackson 编解码器。

	如果需要添加或自定义编解码器，可以创建自定义 `CodecCustomizer` 组件，如以下示例所示：

	```java
	import org.springframework.boot.web.codec.CodecCustomizer;

	@Configuration
	public class MyConfiguration {

		@Bean
		public CodecCustomizer myCodecCustomizer() {
			return codecConfigurer -> {
				// ...
			}
		}

	}
	```

	你也可以利用 [ Boot’s custom JSON serializers and deserializers](https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-json-components)


- #### 27.2.3 Static Content

	默认情况下，Spring Boot 从类路径中名为 `/static`（或 `/public` 或 `/resources` 或 `/META-INF/resources` ）的目录中提供静态内容。它使用 Spring WebFlux 中的 `ResourceWebHandler` ，以便您可以通过添加自己的 `WebFluxConfigurer` 并覆盖 `addResourceHandlers` 方法来修改该行为。

	默认情况下，资源映射到 `/**` ，但您可以通过设置 `spring.webflux.static-path-pattern` 属性来调整它。例如，可以按如下方式将所有资源重新定位到 `/resources/**` ：

	```
	spring.webflux.static-path-pattern=/resources/**
	```

	您还可以使用 `spring.resources.static-locations` 自定义静态资源位置。这样做会将默认值替换为目录位置列表。如果这样做，默认的欢迎页面检测会切换到您的自定义位置。因此，如果启动时这里有 `index.html` 在你的任何位置，那么它就是应用程序的主页。

	除了前面列出的“标准”静态资源位置之外，还为 [Webjars content](http://www.webjars.org/) 制作了一个特例。在 `/webjars/**` 中具有路径的任何资源都是从jar文件提供的，如果它们以Webjars格式打包的话。

	> :sunny: Spring WebFlux 应用程序并不严格依赖于 Servlet API，因此它们不能作为 war 文件部署，也不能使用 `src/main/webapp` 目录。


- #### 27.2.4 Template Engines

	除 REST Web 服务外，您还可以使用 Spring WebFlux 来提供动态 HTML 内容。 Spring WebFlux 支持各种模板技术，包括 Thymeleaf，FreeMarker 和 Mustache。

	Spring Boot包含对以下模板引擎的自动配置支持：

	- [FreeMarker](https://freemarker.apache.org/docs/)

	- [Thymeleaf](https://www.thymeleaf.org/)

	- [Mustache](https://mustache.github.io/)

	当您使用其中一个模板引擎和默认配置时，您的模板将自动从 `src/main/resources/templates` 中获取。


- #### 27.2.5 Error Handling & Custom Error Pages

	- Error Handling

		Spring Boot 提供了 `WebExceptionHandler` 来用合理的方式处理所有错误。它在处理顺序中的位置紧接在 WebFlux 提供的处理程序之前，这被认为是最后的。对于计算机客户端，它会生成一个 JSON 响应，其中包含错误，HTTP 状态和异常消息的详细信息。对于浏览器客户端，有一个“whitelabel” 错误处理程序，它以 HTML 格式呈现相同的数据。您还可以提供自己的 HTML 模板来显示错误。

		自定义此功能的第一步通常涉及使用现有机制，替换或扩充错误内容。为此，您可以添加一个 `ErrorAttributes` 类型的 bean。

		要更改错误处理行为，可以实现 `ErrorWebExceptionHandler` 并注册该类型的bean定义。因为 `WebExceptionHandler` 是一个相当的 low-level ，所以 Spring Boot 还提供了一个方便的 `AbstractErrorWebExceptionHandler` 来让你以 WebFlux 的方式处理错误，如下例所示：

		```
		public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

			// Define constructor here

			@Override
			protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {

				return RouterFunctions
						.route(aPredicate, aHandler)
						.andRoute(anotherPredicate, anotherHandler);
			}

		}
		```

		要获得更完整的描述，您还可以直接继承 `DefaultErrorWebExceptionHandler` 并覆盖特定方法。

	- Custom Error Pages

		如果要显示给定状态代码的自定义HTML错误页面，可以将文件添加到 `/error` 文件夹。错误页面可以是静态 HTML（即，添加到任何静态资源文件夹下）或使用模板构建。文件名应该是确切的状态代码或系列掩码。

		例如，要将 `404` 映射到静态 HTML 文件，您的文件夹结构将如下所示：

		```
		src/
		+- main/
			+- java/
			|   + <source code>
			+- resources/
				+- public/
					+- error/
					|   +- 404.html
					+- <other public assets>
		```

		要使用 Mustache 模板映射所有 `5xx` 错误，您的文件夹结构如下：

		```
		src/
		+- main/
			+- java/
			|   + <source code>
			+- resources/
				+- templates/
					+- error/
					|   +- 5xx.mustache
					+- <other templates>
		```


- #### 27.2.6 Web Filters

	Spring WebFlux 提供了一个 `WebFilter` 接口，可以实现该接口来过滤 HTTP request-response 交换。在应用程序上下文中找到的 `WebFilter` bean将自动用于过滤每个交换。

	如果过滤器的顺序很重要，则可以实现 `Ordered` 或使用 `@Order` 进行注释。 Spring Boot 自动配置可以为您配置 Web 过滤器。执行此操作时，将使用下表中显示的 orders ：

	WebFilter | Order 
	:- | :-|
	`MetricsWebFilter` | `Ordered.HIGHEST_PRECEDENCE + 1`
	`WebFilterChainProxy` (Spring Security) | `-100`
	`HttpTraceWebFilter` | `Ordered.LOWEST_PRECEDENCE - 10`

